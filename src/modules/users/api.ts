import { baseApi } from "../../shared/api";
import type { User, UserId } from "./users.slice";

/* (вместо слайса создаем эндпоинты, инжектируем в основной - по сути создается обьект, для хранения и изменения данных из эндпоинтов, возвращает или сами данные, или состояние запроса - соответственно, используется для работы с внешними источниками данных, БД например, в качестве кеша) */
export const usersApi = baseApi.injectEndpoints({
    endpoints: (create) => ({ /* (принимает встроенный обьект(create или любое другое название) с методами создания эндпоинтов - query, mutation и infiniteQuery) */
        /* (данные из этого обьекта получаем в любом компоненте, обращаясь к обьекту и эндпоинту - например usersApi.useGetUsersQuery() - название метода генерируется из use+ИмяЭндпоинта+Метод, возвращает или сами данные запроса, или текущее состояние запроса) */
        getUsers: create.query<User[], void>({ /* (создаем эндпоинт, типизируем в формате <возвращаемое значение(User[]), передаваемый аргумент(void)>)) */
            // query: () => ({url: "/users", headers: {}}) /* (можно передавать обьектом или просто строкой) */
            query: () => "/users",
        }),
        getUser: create.query<User, UserId>({ /* (типизируем в формате <возвращаемое значение(User[]), передаваемый аргумент(UserId)>)) */
            query: (userId) => `/users/${userId}`,
        }),
        deleteUser: create.mutation<void, UserId>({
            query: (userId) => ({
                method: "DELETE",
                url: `users/${userId}`,
                // body: 
            })
        }),
    }),
    overrideExisting: true, /* (флаг для отображения изменений в коде без перезагрузки страницы) */
})

// export const {useGetUsersQuery} = usersApi; /* (можно сразу экспортировать отдельные эндпоинты - генерирует название как use+ИмяЭндпоинта+Метод) */